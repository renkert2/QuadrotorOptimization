classdef FlightLog < handle
    properties (Constant)
        RawVarNames string = [...
            "ACC1_label";...
            "ACC2_label";...
            "ACC3_label";...
            "ADSB_label";...
            "AHR2";...
            "AHR2_label";...
            "ARM_label";...
            "ARSP_label";...
            "ASP2_label";...
            "ATT";...
            "ATT_label";...
            "BAR2_label";...
            "BAR3_label";...
            "BARO";...
            "BARO_label";...
            "BAT";...
            "BAT2_label";...
            "BAT3_label";...
            "BAT4_label";...
            "BAT5_label";...
            "BAT6_label";...
            "BAT7_label";...
            "BAT8_label";...
            "BAT9_label";...
            "BAT_label";...
            "BCL2_label";...
            "BCL3_label";...
            "BCL4_label";...
            "BCL5_label";...
            "BCL6_label";...
            "BCL7_label";...
            "BCL8_label";...
            "BCL9_label";...
            "BCL_label";...
            "BCN_label";...
            "CAM_label";...
            "CESC_label";...
            "CMD_label";...
            "CSRV_label";...
            "CTRL";...
            "CTRL_label";...
            "CTUN";...
            "CTUN_label";...
            "D16_label";...
            "D32";...
            "D32_label";...
            "DFLT_label";...
            "DMS_label";...
            "DSF";...
            "DSF_label";...
            "DSTL_label";...
            "DU16_label";...
            "DU32";...
            "DU32_label";...
            "ERR_label";...
            "ESC1_label";...
            "ESC2_label";...
            "ESC3_label";...
            "ESC4_label";...
            "ESC5_label";...
            "ESC6_label";...
            "ESC7_label";...
            "ESC8_label";...
            "EV";...
            "EV_label";...
            "FMTU_label";...
            "FMT_label";...
            "GMB1_label";...
            "GMB2_label";...
            "GMB3_label";...
            "GPA";...
            "GPA2_label";...
            "GPAB_label";...
            "GPA_label";...
            "GPS";...
            "GPS2_label";...
            "GPSB_label";...
            "GPS_label";...
            "GRAW_label";...
            "GRXH_label";...
            "GRXS_label";...
            "GUID_label";...
            "GYR1_label";...
            "GYR2_label";...
            "GYR3_label";...
            "IMT2_label";...
            "IMT3_label";...
            "IMT_label";...
            "IMU";...
            "IMU2";...
            "IMU2_label";...
            "IMU3_label";...
            "IMU_label";...
            "IOMC";...
            "IOMC_label";...
            "ISBD_label";...
            "ISBH_label";...
            "MAG";...
            "MAG2";...
            "MAG2_label";...
            "MAG3_label";...
            "MAG_label";...
            "MAVC_label";...
            "MAV_label";...
            "MODE";...
            "MODE_label";...
            "MOTB";...
            "MOTB_label";...
            "MSG";...
            "MSG1";...
            "MSG_label";...
            "MULT";...
            "MULT_label";...
            "NK11_label";...
            "NK12_label";...
            "NK13_label";...
            "NK14_label";...
            "NKF0_label";...
            "NKF1";...
            "NKF1_label";...
            "NKF2";...
            "NKF2_label";...
            "NKF3";...
            "NKF3_label";...
            "NKF4";...
            "NKF4_label";...
            "NKF5";...
            "NKF5_label";...
            "NKF6";...
            "NKF6_label";...
            "NKF7";...
            "NKF7_label";...
            "NKF8";...
            "NKF8_label";...
            "NKF9";...
            "NKF9_label";...
            "NKQ1";...
            "NKQ1_label";...
            "NKQ2";...
            "NKQ2_label";...
            "NKQ3_label";...
            "NKT1";...
            "NKT1_label";...
            "NKT2";...
            "NKT2_label";...
            "OABR_label";...
            "OADJ_label";...
            "OF_label";...
            "ORGN";...
            "ORGN_label";...
            "PARM";...
            "PIDA";...
            "PIDA_label";...
            "PIDP";...
            "PIDP_label";...
            "PIDR";...
            "PIDR_label";...
            "PIDS_label";...
            "PIDY";...
            "PIDY_label";...
            "PL_label";...
            "PM";...
            "PM_label";...
            "POS";...
            "POS_label";...
            "POWR";...
            "POWR_label";...
            "PRX_label";...
            "PSC";...
            "PSC_label";...
            "PTUN_label";...
            "RAD_label";...
            "RALY_label";...
            "RATE";...
            "RATE_label";...
            "RCIN";...
            "RCIN_label";...
            "RCOU";...
            "RCOU_label";...
            "RFND_label";...
            "RPM_label";...
            "RSSI_label";...
            "SBFE_label";...
            "SBPH_label";...
            "SBRE_label";...
            "SBRH_label";...
            "SBRM_label";...
            "SIDD_label";...
            "SIDS_label";...
            "SIM_label";...
            "SRTL";...
            "SRTL_label";...
            "Seen";...
            "TERR";...
            "TERR_label";...
            "TRIG_label";...
            "UBX1";...
            "UBX1_label";...
            "UBX2";...
            "UBX2_label";...
            "UBY1_label";...
            "UBY2_label";...
            "UNIT";...
            "UNIT_label";...
            "VIBE";...
            "VIBE_label";...
            "VISO_label";...
            "WENC_label";...
            "XK11_label";...
            "XK12_label";...
            "XK13_label";...
            "XK14_label";...
            "XKF0_label";...
            "XKF1_label";...
            "XKF2_label";...
            "XKF3_label";...
            "XKF4_label";...
            "XKF5_label";...
            "XKF6_label";...
            "XKF7_label";...
            "XKF8_label";...
            "XKF9_label";...
            "XKFD_label";...
            "XKQ1_label";...
            "XKQ2_label";...
            "XKQ3_label";...
            "XKV1_label";...
            "XKV2_label"]
    end
    properties
        Raw struct
        Data struct
        
        Components ComponentData
    
        StartingVoltage double % Used for calibration of Voltage signal
        EndingVoltage double % Used for calibration of Voltage signal

        BatteryLookup BattLookup
    end
    
    properties (SetAccess = private) 
        FlightTime duration
        ActiveTimes datetime
    end
    
    properties (Dependent)
        BootTime datetime
        StartingSOC double
        EndingSOC double
        BatteryResistance double
        
        VehicleMass double % Mass of vehicle, All components including battery and frame
    end
    
    properties (Hidden)
       BattNs double
       BattCapacity double
    end
    
    methods
        function obj = FlightLog(file, CD)
            s = load('LiPo_42V_Lookup.mat', 'LiPo_42V_Lookup');
            obj.BatteryLookup = s.LiPo_42V_Lookup;
            
            varnamecell = cellstr(obj.RawVarNames);
            raw = load(file, '-mat', varnamecell{:});
            obj.Raw = raw;
            
            if nargin == 2
                obj.Components = CD;
            end
        end
        
        function set.VehicleMass(obj, mass)
            valid_flag = false;
            if ~isempty(obj.Components)
                valid_flag = ismember("Frame", [obj.Components.Component]);
            end
            assert(valid_flag, "Frame component must be set before vehicle mass");
            
            setFrameMass(obj, mass)
        end
        
        function m = get.VehicleMass(obj)
            single_comps = filterComponent(obj.Components, ["Frame", "Battery"]);
            single_tbl = table(single_comps);
            single_tbl = single_tbl{end};
            
            quad_comps = filterComponent(obj.Components, ["PMSMInverter", "PMSMMotor", "Propeller"]);
            quad_tbl = table(quad_comps);
            quad_tbl = quad_tbl{end};
            
            m = sum(single_tbl.Mass) + 4*sum(quad_tbl.Mass); 
        end
        
        function init(obj)
            obj.Data = makeDataStruct(obj);
            obj.Data = processTimeUS(obj);
            setVoltCorr(obj);
            setSOCCurve(obj);
            setESCPWM(obj);
            setActiveTimes(obj);
            setFlightTime(obj);
        end
                
        function plot(obj, xfield, yfields)
            arguments
                obj
                xfield (1,2) string
                yfields (:,2) string
            end
            
            x = obj.Data.(xfield(1,1)).(xfield(1,2));
            N_y = size(yfields,1);
            
            t = tiledlayout(N_y,1);
            title(t,"Log Data");
            
            for i = 1:N_y
                nexttile
                y = obj.Data.(yfields(i,1)).(yfields(i,2));
                plot(x,y);
                ylabel(sprintf("%s:%s", yfields(i,1),yfields(i,2)));
            end
            xlabel(sprintf("%s:%s",xfield(1,1),xfield(1,2)));
        end
        
        function p = plotTime(obj, ycat, yfields, opts)
            arguments
                obj
                ycat (1,1) string
                yfields
                opts.ActiveTime logical = false
                opts.DurationTime logical = false
            end
             
            N_y = size(yfields,2);
            
            p = matlab.graphics.GraphicsPlaceholder.empty(N_y,0);
            for i = 1:N_y
                if (~opts.ActiveTime) && opts.DurationTime
                    x = obj.Data.(ycat).TimeUS/1e6;
                    x = seconds(x);
                else
                    x = obj.Data.(ycat).Time;
                end
                if isstring(yfields)
                    y = obj.Data.(ycat).(yfields(i));
                else
                    y = yfields(:,i);
                end
                if opts.ActiveTime
                    [x, I_act] = obj.time2ActiveTime(x);
                    x = x(I_act);
                    y = y(I_act);
                end
                p(i) = plot(x,y);
                
                if isstring(yfields)
                    s = sprintf("%s:%s", ycat,yfields(i));
                    p(i).DisplayName = s;
                end
                hold on 
            end
            hold off
            legend('-DynamicLegend');
        end
        
        function [active_times, flight_I] = setActiveTimes(obj, opts)
            arguments
                obj
                opts.ThOutThreshold double = 0.01
            end
            ThO = obj.Data.CTUN.ThO;
            flight_I = ThO > opts.ThOutThreshold;
            
            I_diff = diff([0; flight_I]);
            starts = I_diff == 1;
            ends = I_diff == -1;
            
            times = obj.Data.CTUN.Time;
            active_times = [times(starts) times(ends)];
            obj.ActiveTimes = active_times;
        end
        
        function [ft] = setFlightTime(obj)
            time_deltas = obj.ActiveTimes(:,2) - obj.ActiveTimes(:,1);
            ft = sum(time_deltas);
            obj.FlightTime = ft;
        end
        
        function t = get.BootTime(obj)
            BOOT_Wks = obj.Data.GPS.GWk(1);
            BOOT_Ms = obj.Data.GPS.GMS(1);
            epoch_date = datetime(1980,01,06, 'TimeZone', 'UTC') + calweeks(BOOT_Wks);
            t = epoch_date + seconds(BOOT_Ms/1000);
            t.TimeZone = "America/Chicago";
        end
        
        function [tact, I_act] = time2ActiveTime(obj, t)
            N_int = size(obj.ActiveTimes,1);
            tact = seconds(zeros(size(t)));
            I_act = false(size(t));
            for i = 1:N_int
                int = obj.ActiveTimes(i,:);
                
                if i == 1
                    prev_end = seconds(0);
                end
                
                act_I = (int(1) <= t) & (t <= int(2));
                
                if i == N_int
                    inact_next = (t > int(2));
                else
                    next_start = obj.ActiveTimes(i+1,1);
                    inact_next = (t > int(2)) & (t < next_start);
                end
                
                I_act(act_I) = true;
                tact(act_I) = (t(act_I) - int(1)) + prev_end;
                prev_end = tact(find(act_I,1,'last'));
                tact(inact_next) = prev_end;
            end
        end
        
        function t = convTimeUS(obj, time_us)
            t = obj.BootTime + seconds(time_us/1e6);
        end
        
        function v_corr = setVoltCorr(obj)
            bat = obj.Data.BAT;
            v = bat.Volt;
            
            f_corr_start = obj.StartingVoltage - mean(v(1:10));
            f_corr_end = obj.EndingVoltage - mean(v(end-10:end));
            f_corr = linspace(f_corr_start, f_corr_end, numel(v))';
            
            v_corr = v + f_corr;
            obj.Data.BAT.VoltCorr = v_corr;
        end
        
        function q = setSOCCurve(obj)
            % Based on V vs. SOC Curve
             bat = obj.Data.BAT;
             v = bat.VoltCorr;
             
             batt_data = filterComponent(obj.Components, "Battery").Data;
             batt_n_s = filterSym(batt_data, "N_s").Value;
             obj.BattNs = batt_n_s;
             batt_cap = filterSym(batt_data, "Q").Value;
             obj.BattCapacity = batt_cap;
             
             
             q = interp1(obj.BatteryLookup.V_OCV * batt_n_s, obj.BatteryLookup.SOC, v, 'pchip', 'extrap');
             q(q > 1) = 1;
             q(q < 0) = 0;
             obj.Data.BAT.SOCVolt = q;
             
             % Current Correction
             i_tot = bat.CurrTot(end);
             i_tot_act = (obj.StartingSOC - obj.EndingSOC)*batt_cap;
             scale_fact = i_tot_act/i_tot;
             obj.Data.BAT.CurrCorr = obj.Data.BAT.Curr*scale_fact;
             obj.Data.BAT.CurrTotCorr = obj.Data.BAT.CurrTot*scale_fact;
             
             % Based on Direct Current Measurement
             i = obj.Data.BAT.CurrTot;
             obj.Data.BAT.SOCCurr = (batt_cap*obj.StartingSOC - i)./batt_cap;
             
             % Based on Corrected Current
             i = obj.Data.BAT.CurrTotCorr;
             obj.Data.BAT.SOCCurrCorr = (batt_cap*obj.StartingSOC - i)./batt_cap;
        end
        
        function r_p = get.BatteryResistance(obj)
            r = obj.Data.BAT.Res;
            r_p = mean(r,1);
        end
        
        function setESCPWM(obj)
           PWM_min = getParamValue(obj, "MOT_PWM_MIN");
           if PWM_min == 0
               PWM_min = getParamValue(obj, "RC3_MIN");
           end
           
           PWM_max =  getParamValue(obj, "MOT_PWM_MAX");
           if PWM_max == 0
               PWM_max = getParamValue(obj, "RC3_MAX");
           end
           
           rco = obj.Data.RCOU;
           esc_pwm_raw = [rco.C1, rco.C2, rco.C3, rco.C4];
           
           esc_pwm_corr = (esc_pwm_raw - PWM_min)./(PWM_max - PWM_min);
           
           obj.Data.RCOW.ESCPWM = esc_pwm_raw;
           obj.Data.RCOU.ESCU = esc_pwm_corr;
           obj.Data.RCOU.ESCUMean = mean(esc_pwm_corr, 2);
        end
        
        function q = get.StartingSOC(obj)
            q_vec = obj.Data.BAT.SOCVolt;
            q = mean(q_vec(1:10));
        end
        
        function q = get.EndingSOC(obj)
            q_vec = obj.Data.BAT.SOCVolt;
            q = mean(q_vec(end-10:end));
        end
        
        function [v,p] = getParamValue(obj, param)
            params_cell = obj.Data.PARM;
            params = string(params_cell(:,1));
            vals = cell2mat(params_cell(:,2));
            I = contains(params, param);
            v = vals(I);
            p = params(I);
        end
            
        function save(obj)
            t = obj.BootTime;
            t.Format = 'MMddyyyy';
            fname = "FlightLog_"+string(t);
            FL = obj;
            save(fname, 'FL');
        end
        
        function [X,pwm] = thrustCurve(obj, time, t_i)
            % This isn't working quite right.  
            e = getParamValue(obj, "MOT_THST_EXPO");
            max = getParamValue(obj, "MOT_SPIN_MAX");
            min = getParamValue(obj, "MOT_SPIN_MIN");
            pwm_min = getParamValue(obj, "MOT_PWM_MIN");
            if pwm_min == 0
                pwm_min = getParamValue(obj, "RC3_MIN");
            end
            
            pwm_max =  getParamValue(obj, "MOT_PWM_MAX");
            if pwm_max == 0
                pwm_max = getParamValue(obj, "RC3_MAX");
            end
            
%             batt_volt_max = getParamValue(obj, "BAT_VOLT_MAX");
%             batt_volt_rest_est = interp1(obj.Data.BAT.Time, obj.Data.BAT.VoltR, time);
%             
%             batt_voltage_filt = batt_volt_rest_est / batt_volt_max;
%             lift_max = batt_voltage_filt .* (1 - e) + e .* batt_voltage_filt .* batt_voltage_filt;

            batt_voltage_filt = 1;
            lift_max = 1;

            t_r = (-(1.0-e) + sqrt((1.0-e).*(1.0-e) + 4.0 .* e .* lift_max .* t_i ))./(2.0 * e * batt_voltage_filt);
            
            X = min+(max - min)*t_r;
            pwm = pwm_min+(pwm_max - pwm_min)*X;
        end
        
        function ts = getDisturbanceForceTS(obj)
            ax = obj.Data.PSC.AX;
            ay = obj.Data.PSC.AY;
            a = [ax ay zeros(size(ax))];
            f = obj.VehicleMass*a;
            
            [t, I_act] = obj.time2ActiveTime(obj.Data.PSC.Time);
            t = t(I_act);
            f = f(I_act,:);
                
            ts = timeseries(f,seconds(t));
        end
        
        function ts = getRefTrajTS(obj)
            tx = obj.Data.PSC.TPX;
            ty = -obj.Data.PSC.TPY;
            tz = -obj.Data.CTUN.DAlt;
            tz = interp1(obj.Data.CTUN.Time, tz, obj.Data.PSC.Time);
            p = [tx, ty, tz];
            
            [t, I_act] = obj.time2ActiveTime(obj.Data.PSC.Time);
            t = t(I_act);
            p = p(I_act,:);
            
            ts = timeseries(p,seconds(t));
        end
        
        function ts = getBodyStateTS(obj)
            % Order matches states of BodyModel
            PSC = obj.Data.PSC;
            convToPSCTime = @(from_time, from_dat) interp1(from_time, from_dat, PSC.Time);
            
            CTUN = obj.Data.CTUN;
            ATT = obj.Data.ATT;
            NKF1 = obj.Data.NKF1;
            
            
            P(:,1) = PSC.PX;
            P(:,2) = -PSC.PY;
            P(:,3) = convToPSCTime(CTUN.Time, -CTUN.Alt);
            P(:,4) = PSC.VX;
            P(:,5) = -PSC.VY;
            P(:,6) = convToPSCTime(NKF1.Time, NKF1.VD);
            
            convATTToPSC = @(d) convToPSCTime(ATT.Time, ATT.(d));
            P(:,7) = deg2rad(convATTToPSC("Roll"));
            P(:,8) = deg2rad(convATTToPSC("Pitch"));
            P(:,9) = deg2rad(convATTToPSC("Yaw"));
            
            [t, I_act] = obj.time2ActiveTime(obj.Data.PSC.Time);
            t = t(I_act);
            P = P(I_act,:);
            
            ts = timeseries(P, seconds(t));
        end
        
        function ts = getBodyAccelTS(obj)
            % [a_x a_y a_z omega_dot_x omega_dot_y omega_dot_z]
            PSC = obj.Data.PSC;
            convToPSCTime = @(from_time, from_dat) interp1(from_time, from_dat, PSC.Time);
           
            RATE = obj.Data.RATE;
            
            
            IMU = obj.Data.IMU;
            
            a(:,1) = PSC.AX;
            a(:,2) = PSC.AY;
            a(:,3) = convToPSCTime(RATE.Time, RATE.A);
            
            omega_dot(:,1) = convToPSCTime(IMU.Time ,IMU.GyrX);
            omega_dot(:,2) = convToPSCTime(IMU.Time, IMU.GyrY);
            omega_dot(:,3) = convToPSCTime(IMU.Time, IMU.GyrZ);
            
            adat = [a omega_dot];
            [t, I_act] = obj.time2ActiveTime(obj.Data.PSC.Time);
            t = t(I_act);
            adat = adat(I_act,:);
            
            ts = timeseries(adat, seconds(t));
        end
        
        function ave_current = calcAverageCurrent(obj)
            t = obj.Data.BAT.Time;
            [t, I_act] = obj.time2ActiveTime(t);
            t = seconds(t(I_act));
            ave_current = mean(obj.Data.BAT.CurrCorr(I_act)); 
        end
        
        function ft_max = calcMaxFlightTime(obj, final_soc)
            % Caution: This won't be very accurate since current increases
            % as function of SOC
            if numel(obj) == 1
                ft_max = calcMaxFlightTime_(obj, final_soc);
            else
                for i = 1:numel(obj)
                    ft_max(i,1) = calcMaxFlightTime_(obj(i), final_soc);
                end
            end
            
            function ft_max = calcMaxFlightTime_(obj, final_soc)
                % Average Current
                t = obj.Data.BAT.Time;
                [t, I_act] = obj.time2ActiveTime(t);
                t = seconds(t(I_act));
                q = obj.Data.BAT.SOCCurrCorr(I_act); % Could also use raw, uncorrected SOC here if we want to remove the voltage curve variable
                
                if final_soc >= obj.EndingSOC
                    ft_max = interp1(q,t,final_soc);
                else
                    warning("Extrapolating Flight Time")
                    act_curr = obj.Data.BAT.CurrCorr(I_act);
                    ave_current = mean(act_curr(end-200:end-100));
                    ft_max = ((obj.BattCapacity / 1000 * (1 - final_soc))/ave_current)*(60^2); % s
                    
                end
                ft_max = seconds(ft_max);
                ft_max.Format = 'hh:mm:ss';
            end
        end
    end
    
    methods (Access = private)
        function data = makeDataStruct(obj)
            raw_names = string(fields(obj.Raw));
            class_filter = ~contains(raw_names, "_label");
            class_names = unique(raw_names(class_filter));
            
            data = struct();
            for i = 1:numel(class_names)
                class_name = class_names(i);
                label_name = class_name + "_label";
                if ismember(label_name, raw_names)
                    field_names = string(obj.Raw.(label_name));
                    
                    class_raw = obj.Raw.(class_name);
                    
                    class_struct = struct();
                    for j = 1:numel(field_names)
                        class_struct.(field_names(j)) = class_raw(:,j);
                    end
                    data.(class_name) = class_struct;
                else
                    data.(class_name) = obj.Raw.(class_name);
                end
            end
        end
        
        function data_out = processTimeUS(obj)
            data_out = obj.Data;
            class_names = string(fields(data_out));
            for i = 1:numel(class_names)
               class = data_out.(class_names(i));
               if isa(class, 'struct')
                   class_fields = string(fields(class));
                   if ismember("TimeUS", class_fields) && ~ismember("Time", class_fields)
                       data_out.(class_names(i)).Time = convTimeUS(obj, data_out.(class_names(i)).TimeUS);
                   end
               end
            end
        end
        
        function setFrameMass(obj, total_mass)
            % adjusts mass of frame so that the combined component mass
            % matches total mass
            
            mass_delta = total_mass - obj.VehicleMass;
            i_frame = [obj.Components.Component] == "Frame";
            frame_data = obj.Components(i_frame).Data;
            i_frame_mass = [frame_data.Sym] == "Mass";
            
            
            obj.Components(i_frame).Data(i_frame_mass).Value = obj.Components(i_frame).Data(i_frame_mass).Value + mass_delta;
        end
    end
end

